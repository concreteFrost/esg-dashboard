var data1 = '/dashboard/assets/data/treemap.json'

function GetLightestFromColor(bgColor) {
    var hsl = d3.hsl(bgColor);
    hsl.l = 0.965;    
    return  hsl.toString();
}

var chartWidth = 550;
var chartHeight = 450;
var xscale = d3.scale.linear().range([0, chartWidth]);
var yscale = d3.scale.linear().range([0, chartHeight]);
var headerHeight = 16;
var transitionDuration = 500;
var root;
var node;

var minColor = "#0C8F8F";
var minMid = GetLightestFromColor(minColor);
var maxColor = "#FFAD08";
var maxMid = GetLightestFromColor(maxColor);
console.log(minMid);

var colorScale = d3.scale.linear().domain([0, 0.49999, 0.5, 1]).range([minColor, minMid, maxMid, maxColor]);

var tmTTTimeout;
function HideTooltip(){
    clearTimeout(tmTTTimeout);
    d3.select(".protooltip")
        .classed("z-depth-1", false)
        .classed("tmtip", false)
        .transition()
        .duration(500)
        .style("opacity", 0);   
}
function ShowTMTooltip(d, IsContainer){
    var div = d3.select(".protooltip");
    if (div.empty()) {
        div = d3.select("body").append("div")
        .attr("class", "protooltip");
    }
    div.classed("z-depth-1", true)
        .classed("tmtip", true)
        .style("opacity", 0);
    
    div.transition()
        .duration(400)
        .style("opacity", .96);
    div.html(d.ToolTip ? d.ToolTip : IsContainer ? d.name : d.name + ': ' + d.size)
        .style("left", (d3.event.pageX + 10) + "px")
        .style("top", (d3.event.pageY + 20) + "px");
    
    tmTTTimeout = setTimeout(HideTooltip, 5000);    
}

var treemap = d3.layout.treemap()
    .round(false)
    .mode("squarify")
    .size([chartWidth, chartHeight])
    .sticky(true)
    .value(function(d) {
        return d.size;
    });

var svg = d3.select("#body")
    .append("svg:svg")
    .attr("width", chartWidth)
    .attr("height", chartHeight);
var chart = svg.append("svg:g");


$(function() {
    
    node = root = data1;
    var nodes = treemap.nodes(root);
    
    //All nodes that are leaf nodes
    var children = nodes.filter(function(d) {
        return !d.children;
    });
    //All nodes that are parent/container nodes
    var parents = nodes.filter(function(d) {
        return d.children;
    });

    var parentCells = chart.selectAll("g.tmcell.tmparent")
        .data(parents, function(d) {
            return "p-" + d.id;
        });
    
    var parentEnterTransition = parentCells.enter()
        .append("g")
        .attr("class", "tmcell tmparent")
        .on("click", function(d) {
            zoom(node === d ? root : d);
        })   
        .on("mouseover", function (d) {
            ShowTMTooltip(d, true);
        })
        .on("mouseout", function (d) {
            HideTooltip();
        })       
        .append("g") //svg
        .attr("class", "tmclip")
        .attr("width", function(d) {
            return Math.max(0.01, d.dx);
        })
        //.attr("height", headerHeight);
        .attr("height", function(d) {
            return Math.max(0.01, d.dy);
        });
    
    parentEnterTransition.append("rect")
        .attr("width", function(d) {
            return Math.max(0.01, d.dx);
        })
        //.attr("height", headerHeight)
        .attr("height", function(d) {
            return Math.max(0.01, d.dy);
        })
        .attr("class", "tmRect tmheaderBackground")
    
    parentEnterTransition.append('text')
        .attr("class", "tmlabel")
        .attr("transform", "translate(3, 13)")
        .attr("width", function(d) {
            return Math.max(0.01, d.dx);
        })
        .attr("height", headerHeight)
        .text(function(d) {
            return d.name;
        });
    
    // update transition
    var parentUpdateTransition = parentCells.transition().duration(transitionDuration);
    parentUpdateTransition.select(".tmcell")
            .attr("transform", function(d) {
                return "translate(" + d.dx + "," + d.y + ")";
            });
    parentUpdateTransition.select("rect")
            .attr("width", function(d) {
                return Math.max(0.01, d.dx);
            })
            .attr("height", headerHeight)
    
    parentUpdateTransition.select(".tmlabel")
            .attr("transform", "translate(3, 13)")
            .attr("width", function(d) {
                return Math.max(0.01, d.dx);
            })
            .attr("height", headerHeight)
            .text(function(d) {
                return d.name;
            });
    
    // remove transition
    parentCells.exit().remove();

    // create children cells
    /* 
      <g class="cell child" transform>
          <svg class="clip" width="dx" height="dy">
              <rect width="dx" height="dy" class="background" style="fill: color" ></rect>
              <text class="label" x="dx/2" y="dy/2" dy="0.35em" text-anchor="middle" height="dy" width="dx">name</text>
          </svg>
      </g>
    */
    var childrenCells = chart.selectAll("g.tmcell.tmchild")
            .data(children, function(d) {
                return "c-" + d.id;
            });
    // enter transition
    var childEnterTransition = childrenCells.enter()
            .append("g")
            .attr("class", "tmcell tmchild")
            .on("click", function(d) {
                zoom(node === d.parent ? root : d.parent);
            })
            .on("mouseover", function (d) {
                ShowTMTooltip(d, false);
            })
            .on("mouseout", function (d) {
                HideTooltip();
            })        
            .append("g") //svg
            .attr("class", "tmclip");

    childEnterTransition.append("rect")
            .attr("class", "background tmRect")
            .style("fill", function(d) {
                return colorScale(d.color);
            });
    childEnterTransition.append('text')
            .attr("class", "tmlabel")
            .attr('x', function(d) {
                return d.dx / 2;
            })
            .attr('y', function(d) {
                return d.dy / 2;
            })
            .attr("dy", ".35em")
            .attr("text-anchor", "middle")
            .style("display", "none") //label
            .style("fill", function(d) {
                return idealTextColor(colorScale(d.color));
            })
            .text(function(d) {
                return d.name;
            });
    // update transition
    var childUpdateTransition = childrenCells.transition().duration(transitionDuration);
    childUpdateTransition.select(".tmcell")
            .attr("transform", function(d) {
                return "translate(" + d.x + "," + d.y + ")";
            });
    childUpdateTransition.select("rect")
            .attr("width", function(d) {
                return Math.max(0.01, d.dx);
            })
            .attr("height", function(d) {
                return d.dy;
            })
            .style("fill", function(d) {
                return colorScale(d.color);
            });
    childUpdateTransition.select(".tmlabel")
            .attr('x', function(d) {
                return d.dx / 2;
            })
            .attr('y', function(d) {
                return d.dy / 2;
            })
            .attr("dy", ".35em")
            .style("display", "none") //label
            .attr("text-anchor", "middle")
            .text(function(d) {
                return d.name;
            });

    // exit transition
    childrenCells.exit().remove();

    zoom(node);
});


function idealTextColor(bgColor) {
    return  d3.hsl(bgColor).l > 0.4 ? "#000000" : "#ffffff";
}

function zoom(d) {
    
    this.treemap
        .padding([headerHeight / (chartHeight / d.dy), 2, 1, 2])
        .nodes(d);
    
    // moving the next two lines above treemap layout messes up padding of zoom result
    var kx = chartWidth / d.dx;
    var ky = chartHeight / d.dy;
    var level = d;
    var prevNode = node;
    
    xscale.domain([d.x, d.x + d.dx]);
    yscale.domain([d.y, d.y + d.dy]);
    
    var zoomTransition = chart.selectAll("g.tmcell").transition().duration(transitionDuration)
        .attr("transform", function(d) {
            return "translate(" + xscale(d.x) + "," + yscale(d.y) + ")";
        })
        .each("start", function() {
            d3.select(this).select(".tmchild .tmlabel")
                .style("display", "none");
        })
        .each("end", function(d, i) {
        });
    
    zoomTransition.select(".tmclip")
        .attr("width", function(d) {
            return Math.max(0.01, (kx * d.dx));
        })
        .attr("height", function(d) {
            //return d.children ? headerHeight : Math.max(0.01, (ky * d.dy));
            return Math.max(0.01, (ky * d.dy));
        });
    
    zoomTransition.select(".tmlabel")
        .attr("width", function(d) {
            return Math.max(0.01, (kx * d.dx));
        })
        .attr("height", function(d) {
            return d.children ? headerHeight : Math.max(0.01, (ky * d.dy));
        })
        .text(function(d) {
            return d.name;
        });
    
    zoomTransition.select(".tmchild .tmlabel")
        .attr("x", function(d) {
            return kx * d.dx / 2;
        })
        .attr("y", function(d) {
            return ky * d.dy / 2;
        });
    
    zoomTransition.select("rect")
        .attr("width", function(d) {
            return Math.max(0.01, (kx * d.dx));
        })
        .attr("height", function(d) {
            //return d.children ? headerHeight : Math.max(0.01, (ky * d.dy));
            return Math.max(0.01, (ky * d.dy));
        });
    
    node = d;
    
    setTimeout(function(){
         chart.selectAll(".tmchild .label")
            .style("display", "none");
        
        chart.selectAll(".tmcell.tmchild")
        .filter(function(d) {
            // only get the children for selected group
            return d.parent === level; 
        })
        .select(".tmlabel")
        .style("display", "")
        .style("fill", function(d) {
            return idealTextColor(colorScale(d.color));
        });
    }, 250);
    
    if (d3.event) {
        d3.event.stopPropagation();
    }
}
